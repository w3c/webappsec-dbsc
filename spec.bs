<pre class="metadata">
Title: Device Bound Session Credentials
Shortname: dbsc
Level: 1
Indent: 2
Status: ED
Group: webappsec
ED: https://w3c.github.io/webappsec-dbsc/
Editor: Kristian Monsen 76841, Google, kristianm@google.com
Editor: Daniel Rubery 162789, Google, drubery@google.com
Editor: thefrog@chromium.org 164860, Google, thefrog@chromium.org
Abstract: Device Bound Sessions Credentials (DBSC) aims to prevent hijacking via cookie theft by building a protocol and infrastructure that allows a user agent to assert possession of a securely-stored private key. DBSC is a Web API and a protocol between user agents and servers to achieve this binding.
Repository: https://github.com/w3c/webappsec-dbsc/
Markup Shorthands: css no, markdown yes
Mailing List:
</pre>

<pre class="link-defaults">
spec:dom; type:interface; for:/; text:Document
spec:dom; type:dfn; for:/; text:element
spec:url; type:dfn; for:/; text:url
spec:fetch; type:dfn; for:/; text:response
spec:fetch; type:dfn; for:/; text:request
spec:html; type:element; text:script
spec:html; type:element; text:link
spec:fetch; type:dfn; text:name
spec:fetch; type:dfn; text:value
spec:infra; type:dfn; text:list
spec:infra; type:dfn; text:tuple
spec:permissions; type:dfn; text:feature
</pre>

<pre class="anchors">
spec: RFC9651;urlPrefix:https://datatracker.ietf.org/doc/html/rfc9651#;type:dfn
  text: sf-dictionary; url: dictionary
  text: sf-inner-list; url: inner-list
  text: sf-item; url: item
  text: sf-list; url: list
  text: sf-string; url: string
  text: sf-token; url: token
  text: sf-parameter; url: name-parameters
  url:text-parse;text:parsing structured fields
</pre>

# Introduction # {#intro}

<em>This section is not normative.</em><br/>
<em>Note this is a very early drafting for writing collaboration only</em>

The web is built on a stateless protocol. To provide required functionality, web
applications store data locally on a user's computer. This is used for logged in
user sessions that can last for a long time.

In general user agents do not have a secure way of storing data supporting these
activities across commonly used operating systems, and actions authenticated by
this data may have serious consequences, for example transferring money from a
bank account.

This document defines a new API, Device Bound Sessions Credentials (DBSC), that
enables the server to verify that a session cannot be exported from a device by
using commonly available TPMs, or similar APIs, that are designed for this
purpose.

The goal is to provide users with a safe and secure experience, while offering
the use cases users are already used to. At the same time we want to ensure that
the users privacy is respected with no new privacy identifiers being leaked by
this protocol.

## Examples ## {#examples}
Device Bound Session Credentials are designed to make users more secure in
different situations. Some of the use cases of DBSC are:

### Signed in session ### {#example-signin}
<div class="example" id="signin-example">
  A user logs in to their social account. To protect the user's private data the
  site protects the logged in session with a DBSC session. If malware tries to
  log in with the same cookie file on a different device, the site can detect
  and refuse this as an unauthorized user.
</div>

### Device integrity ### {#example-device-integrity}
<div class="example" id="device-integrity-example">
  A commercial site has different ways of detecting unauthorized login attempts.
  A DBSC session on the device could be used to see which users have logged on to
  this device before.
</div>

### Device reputation ### {#example-device-reputation}
<div class="example" id="device-reputation-example">
  A payment company hosted at site `payment.example.com` could create a session
  bound to when users visit commercial site `shopping.example.com`. It could
  track the reliability of the device over time to decide how likely a
  transaction is legitimate.
</div>

# Security Considerations # {#security-considerations}
The goals of DBSC are to reduce session theft by offering an alternative to
long-lived cookie bearer tokens and to allow session authentication to be
bound to the user's device. This makes the internet safer for users in that it
is less likely their identity is abused, as malware is forced to act locally and
thus becomes easier to detect and mitigate. At the same time the goal is to
disrupt the cookie theft ecosystem and force it to adapt to new protections long
term.

As long as the session is valid and was registered to an uncompromised device, a
host can know with cryptographic certainty that it is on the same device as the
one the session was originally bound to.

In order to ensure this, session private keys should be stored in a way
that cannot be exfiltrated by locally running malware, whenever possible.

## Non-goals ## {#non-goals}
DBSC will not prevent temporary access to the browser session while the attacker
is resident on the user's device. The private key should be stored as safely as
modern operating systems allow, preventing exfiltration of the session private
key, but the signing capability will likely still be available for any program
running as the user on the user's device.

DBSC will also not prevent an attack if the attacker is replacing or injecting
into the user agent at the time of session registration as the attacker can bind
the session either to keys that are not TPM bound, or to a TPM that the attacker
controls permanently.

DBSC is not designed to give hosts any sort of guarantee about the
specific device a session is registered to, or the state of this device.

# Privacy Considerations # {#privacy-considerations}
The goal of the DBSC protocol is to introduce no additional surface for user
tracking: implementing this API (for a browser) or enabling it (for a website)
should not entail any significant user privacy tradeoffs.

Some of the consideration taken to ensure this:

- Lifetime of a session/key material: This should provide no additional client
  data storage (i.e., a pseudo-cookie). As such, we require that browsers MUST
  clear sessions and keys when clearing other site data (like cookies).
- Implementing this API should not meaningfully increase the entropy of
  heuristic device fingerprinting signals. In particular, DBSC
  should not leak any stable TPM-based device identifier.
- As this API MAY allow background "pings" for performance, this must not enable
  long-term tracking of a user when they have navigated away from the connected
  site.
- Each session has a separate new key created, and it should not be possible to
  detect that different sessions are from the same device.

## Cookies considerations ## {#privacy-cookies}
It should be impossible for a site to use this API to circumvent the same origin
policy, 3P cookie policies, etc. Due to the complexity of current and changing
cookie behavior and the tight integration between DBSC and cookies, the current
solution is that each user agent should use the same policy for DBSC as it uses
for cookies. If the DBSC cookie credential would not apply to a network request
based on user settings, applied policies, or user agent implementation details,
neither would any of the additional DBSC behavior. This ensures no new privacy
behavior due to implementing DBSC.

## Timing side channel leak ## {#privacy-side-channel-leak}
If third party cookies are enabled it is possible for an attacker to leak
whether or not a user is authenticated by measuring how long the request takes
as the refresh is quite slow, partially due to the latency of TPM operations. 

This is mitigated by the `allowed_refresh_initiators` field in session
configuration, which can be used to strictly limit the sites that can trigger
DBSC refreshes. This cannot be replaced by existing solutions
(e.g. X-Frame-Options) because the existing solutions only apply after the
request has completed, and DBSC must choose whether to refresh before the
request has started.

## Federated sessions ## {#federated-sessions}

Many sites use a federated login mechanism with no browser involvement,
frequently depending on link decoration (e.g. OIDC). In order to achieve DBSC's
goal of easy adoptability, we want these sites to be able to protect themselves
from cookie theft without a full rewrite of their authentication flows. Ideally,
Relying Parties (RPs) could simply establish a DBSC session independently of the
Identity Provider (IdP). Unfortunately, most IdPs do not require a password if
the user is already logged in. If user interaction isn't required, malware can
use its temporary access to the user's machine to mimic the login flow and
establish a DBSC session with a new private key the malware created and can
exfiltrate. This violates the security goals of DBSC.

Therefore, we need to link the RP and IdP session in some way. The simplest way
to do this is for the IdP and RP to simply use the same session key. Since we
assume the IdP's session was established before the malware compromised the
device, we trust that the private key is stored securely. But sharing keys across
sites has complex privacy properties. In order to mitigate the privacy risks of
sharing a high-entropy identifier, we require that the RP already know the
public key and session identifier for the IdP's session. The RP will include the
IdP URL, session id, and key in the [:Secure-Session-Registration:] header. If
the key is correct, the user agent will create a session on the RP with the same
key as the IdP.

There is also a potential risk of malicious RPs and IdPs collaborating to try to
identify users in cases where the RP and IdP can't already share information
(e.g. when there are protections against fingerprinting or link decoration). The
RPs could simply try to guess many public keys until they found a match, giving
them a unique identifier for the user. This would allow a collaborating RP and
IdP to share a user's identity across sites, outside of the intended mechanisms
for cross-site identity linking. To prevent this, user agents should include
significant backoff or quotas on registration attempts (this is also recommended
to avoid denial of service on the TPM). Note that the security properties of
DBSC rely on a cryptographic assumption that it is hard to get two users with
the same key pair, so querying whether a user has a specific DBSC public key on
the IdP is much less than a one bit of entropy.

In order to further limit the value of successfully unmasking a user, we also
require opt-in from the IdP through a `.well-known`. Browsers should limit the
number of RP origins in that list. This will ensure that large groups of sites
cannot collaborate to unmask a single high-value user as they browse the web.

<div class="example" id="federated-sessions-example">
Suppose the owners of `example.com` also run `example.co.uk`. Login always
happens on `example.com`, and is propagated to `example.co.uk` through link
decoration. In order to protect both sites with a DBSC session, `example.com`
should continue to use its existing [:Secure-Session-Registration:] header:

```
Secure-Session-Registration: (ES256);path="/register";challenge="challenge"
```

When extending the DBSC session to `example.com.uk`, the site should append new
parameters to their `Secure-Session-Registration` header:

```
Secure-Session-Registration: (ES256);path="/register";challenge="challenge";provider_key="abc";provider_id="example.com id";provider_url="https://example.com"
```

Assuming `example.com` has the appropriate .well-known entries, this will cause
`example.co.uk` to register a new DBSC session using the same key as the session
on `example.com`. This allows DBSC to protect `example.co.uk` without requiring
users to reauthenticate on `example.com` at login.  </div>

# Alternatives considered # {#alternatives}

## WebAuthn and silent mediation ## {#alternatives-webauthn}

WebAuthn provides sites with certain key management capabilities, so it may be
possible to extend it to meet the same goals as DBSC. We do not take this
approach because WebAuthn's focus on interactive user sign in leads to several
properties for its API that are contrary to the goals of a feature like
DBSC. For example, WebAuthn credentials are not tied to specific sessions. They
are meant to be long-lived and are not cleared along with site data. This does
not line up well with the necessary privacy properties for session
keys. Similarly, WebAuthn credentials are designed for use with explicit user
intent. Extending WebAuthn to subsume the functionality that DBSC provides would
require WebAuthn to establish a different kind of key that can be used
silently. This introduces extra complexity for both WebAuthn and DBSC. Instead,
we take the position that WebAuthn aims to provide secure sign in and DBSC is
complementary, protecting users after sign in.

# Server considerations # {#server-considerations}

In order to use DBSC, site owners need to establish two new endpoints:
the registration endpoint and the refresh endpoint.

The registration endpoint is contacted asynchronously after the browser receives
the [:Secure-Session-Registration:] header. This endpoint should:
- Serve the session config, including a new session id.
- Persist and associate the request's public key with the session id.

The refresh endpoint is much more sensitive. This endpoint is contacted every
time a request is made with an expired bound cookie, and its response blocks
the original request. Failure to respond or restore the bound cookie may
cause browser agents to begin denial-of-service prevention mechanisms, or even
terminate the session. Both could lead to future requests without bound
cookies. The expected behavior of this endpoint is:
- Look up the public key and recent challenges for the session by id.
- Validate the [:Secure-Session-Response:] header has signed a recent challenge with
  the correct key. Note that due to network latency and race conditions, it's
  possible to receive a signature for an old challenge after issuing a new
  challenge.
- Issue new bound cookies.
- Optionally update the current session config.

The refresh endpoint is likely to directly leak login state if cross-site
fetches are allowed. Servers can check for a valid [:Sec-Secure-Session-Id:]
header to ensure that incoming requests are initiated by the user agent and not
a cross-site request. It's also recommended to set a narrow CORS policy on this
endpoint and not allow cross-site origins to make requests with credentials. The
CORS integration for DBSC has been designed to make this possible by implicitly
including credentials when the deferred request does. For similar reasons, it's
also recommended that the refresh endpoint refuse to be embedded via the
`X-Frame-Options` or `Cross-Origin-Resource-Policy` headers.

<div class="example" id="timing-leak-cors">
Suppose `example.com` has two endpoints:
- `/authenticated` will return `Access-Control-Allow-Credentials` for any
  requesting origin.
- `/refresh` is the the DBSC refresh endpoint.

The site wants DBSC to protect cross-site requests to `/authenticated`, and
believes that the risk from timing side channels on this one endpoint are
minimal. If we did not implicitly allow credentials for the refresh request
triggered by the user agent, then `/refresh` would be required to return
`Access-Control-Allow-Credentials` for any requesting origin. Now attackers can
very directly leak login state by fetching `/refresh` directly.

By implicitly allowing credentials, the `/refresh` endpoint can refuse to ever
return `Access-Control-Allow-Credentials`. It will still receive credentialled
requests in the context of a DBSC refresh. Other sites will be unable to
directly fetch the endpoint with credentials, preventing an easy cross-site leak
of login state.
</div>

Sites using federated login with DBSC (see [[#federated-sessions]]) should
ensure that only sessions with the federated key are accepted. Security of
federated sessions relies on the machine being uncompromised at Identity
Provider (IdP) login, since malware can use temporary access to the machine to
register a session on the Relying Party (RP) with new keys. Therefore RPs should
only accept sessions registered with the appropriate public keys they received
from the IdP.


# Framework # {#framework}
This document uses ABNF grammar to specify syntax, as defined in [[!RFC5234]]
and updated in [[!RFC7405]], along with the `#rule` extension defined in
<a href="https://tools.ietf.org/html/rfc7230#section-7">Section 7</a> of
[[!RFC9112]], and the `quoted-string` rule defined in
<a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">Section 3.2.6</a>
of the same document.

This document depends on the Infra Standard for a number of foundational
concepts used in its algorithms and prose [[!INFRA]].

## Session store ## {#framework-session-store}
The user agent maintains a <dfn>session store</dfn>. It is an [=ordered map=]
from [=host/registrable domain=] to [=session by id=]. Sessions should persist
across user agent restarts.

## Sessions by id ## {#framework-sessions-id}
A <dfn>session by id</dfn> is an [=ordered map=] from
[=device bound session/session identifier=] to [=device bound session=] for a
given [=host/registrable domain=].

## Device bound session ## {#framework-session}
A <dfn>device bound session</dfn> is a [=struct=] with the following
[=struct/items=]:
<dl dfn-for="device bound session">
  : <dfn>session identifier</dfn>
  :: a [=string=] that is a unique identifier of a session on an
    [=host/registrable domain=]
  : <dfn>refresh URL</dfn>
  :: a [=string=] that is representing the [=URL=] to be used to refresh the
    session
  : <dfn>cached challenge</dfn>
  :: a [=string=] that is to be used as the next challenge for this session
  : <dfn>session scope</dfn>
  :: a [=/session scope=] defining which [=URLs=] are in scope for this session
  : <dfn>session credentials</dfn>
  :: a [=list=] of [=/session credentials=] used by the session, derived from
    [=JSON session credentials=]
  : <dfn>expiration timestamp</dfn>
  :: a [=moment=] when this session should be removed.
  : <dfn>session key</dfn>
  :: a key pair used by the session. The private key
    should be stored in a secure manner, see [[#security-considerations]].
  : <dfn>allowed refresh initiators</dfn>
  :: a [=list=] of [=strings=] describing which hosts are allowed to initiate
    DBSC refreshes due to non-CORS requests. See
    [[#algo-request-allows-refresh]] for details.
</dl>

## Session scope ## {#framework-scope}
The <dfn>session scope</dfn> is a [=struct=] with the following
[=struct/items=]:
<dl dfn-for="session scope">
  : <dfn>origin</dfn>
  :: The [=/origin=] this session was registered for.
  : <dfn>include site</dfn>
  :: a [=boolean=] indicating if the session applies to an entire site or just an origin.
  : <dfn>scope specifications</dfn>
  :: a [=list=] of [=/scope specifications=] used by the session
</dl>

## Scope specification ## {#framework-scope-specification}
The <dfn>scope specification</dfn> is a [=struct=] with the following
[=struct/items=]:
<dl dfn-for="scope specification">
  : <dfn>type</dfn>
  :: a [=string=] to be either "include" or "exclude", defining if the item
    defined in this struct should be added or removed from the scope
  : <dfn>host</dfn>
  :: a [=string=] defining the domain or domain pattern that must match for this scope specification to apply.
  : <dfn>path</dfn>
  :: a [=string=] that defines the path part of this scope specification
</dl>

## Session credential ## {#framework-session-credential}
The <dfn>session credential</dfn> is a [=struct=] with the following
[=struct/items=]:
<dl dfn-for="session credential">
  : <dfn>name</dfn>
  :: a [=string=] that defines the name of the credential cookie
  : <dfn>attributes</dfn>
  :: a [=string=] that defines the other attributes of the credential cookie.
    User agents should supply the same defaults here as they would for cookies.
</dl>

## Registrable origin label## {#framework-registrable-origin-label}
The <dfn>registrable origin label</dfn> of a [=/domain=] is the first
[=domain label=] of the [=registrable domain=] of a [=/domain=], or null
if the [=registrable domain=] is null. For example, the [=registrable
origin label=] of both `example.co.uk` and `www.example.de` is `example`
if both `co.uk` and `de` are [=public suffixes=].

# Algorithms # {#algorithms}
## Identify session ## {#algo-identify-session}
<div class="algorithm" data-algorithm="identify-session">
  This algorithm describes how to
  <dfn export dfn-for="algorithms">identify a session</dfn> out of all the
  sessions that exist on a user agent. The
  [=device bound session/session identifier=] is unique within a
  [=host/registrable domain=].

  Given a [=URL=] (|url|) and [=device bound session/session identifier=]
  (|session identifier|), this algorithm returns a [=device bound session=] or
  null if no such session exists.

  1. Let |domain| be the [=host/registrable domain=] of |url|'s [=url/host=].
  1. Let |domain sessions| be the user agent's [=session store=][|domain|] as a
     [=/session by id=]
  1. Return |domain sessions|[|session identifier|]
</div>

## Identify if a URL is in scope of a session ## {#algo-url-in-scope}
<div class="algorithm" data-algorithm="url-in-scope">
  This algorithm describes how to determine if a URL is in scope of a
  device bound session. Given a [=URL=] (|URL|) and [=session=] (|session|), returns
  "include" if |URL| is in scope, and "exclude" otherwise.

  1. Let |scope| be |session|'s [=device bound session/session scope=].
  1. If |scope|'s [=include site=] is true, return "exclude" if |URL|'s
     [=/origin=] is not [=/same site=] with |scope|'s [=session scope/origin=].
  1. If |scope|'s [=include site=] is false, return "exclude" if |URL|'s
     [=/origin=] is not [=same origin=] with |scope|'s [=session scope/origin=].
  1. If the |URL| matches the |session|'s [=refresh URL=], return "exclude".
  1. [=list/For each=] |scope specification| in |scope|'s [=scope specifications=]:
    1. Let |host pattern| be |scope specification|'s [=scope 
       specification/host=], and |path pattern| be |scope
       specification|'s [=scope specification/path=].
    1. If running [[#algo-host-pattern-matches]] on |URL|'s [=url/host=]
       and |host pattern| returns false, [=iteration/continue=].
    1. If any of the following hold, return |scope specification|'s [=scope specification/type=]:
       1. |URL|'s [=url/path=] is exactly |path pattern|.
       1. |path pattern| ends in '/' and |URL|'s [=url/path=] starts with |path pattern|.
       1. |URL|'s [=url/path=] starts with |path pattern| followed by a '/'.
  1. Return "include".
</div>

## Identify if a request is allowed to refresh ## {#algo-request-allows-refresh}
<div class="algorithm" data-algorithm="request-allows-refresh">
  This algorithm describes how to determine if a request is allowed to
  be refreshed by a device bound session. Given a [=request=]
  (|request|) and [=session=] (|session|), returns "allowed" if
  |request| can trigger a refresh, and "disallowed" otherwise.

  1. If |session|'s [=device bound session/session scope=]'s [=include
     site=] is true, and |request|'s [=request/origin=] is [=/same
     site=] with |session|'s [=device bound session/session scope=]
     [=session scope/origin=], return "allowed".
  1. If |session|'s [=device bound session/session scope=]'s [=include
     site=] is false, and |request|'s [=request/origin=] is [=/same
     origin=] with |session|'s [=device bound session/session scope=]
     [=session scope/origin=], return "allowed".
  1. [=list/For each=] |initiator pattern| in |session|'s
     [=allowed refresh initiators=]:
    1. If running [[#algo-host-pattern-matches]] on |request|'s
       [=request/origin=]'s [=origin/host=] and |initiator pattern|
       returns true, return "allowed".
  1. Return "disallowed".

## Identify if a host matches a pattern ## {#algo-host-pattern-matches}
<div class="algorithm" data-algorithm="host-pattern-matches">
  This algorithm describes how to determine if a [=url/host=] (|host|)
  matches a |pattern|. It returns true if |pattern| covers |host|.

  1. If |pattern| equals '*', return true.
  1. If |pattern| starts with '*':
    1. If |pattern| does not start with '*.', return false.
    1. Return true if |host| ends with all but the first character
       of |pattern|.
  1. Return true if |host| is equal to |pattern|.
  
<div class="example" id="host-pattern-matches-example">
  Some examples of pattern matches:
  - `example.com` matches `*`
  - `example.com` matches `example.com`
  - `example.com` does not match `*.example.com`
  - `subdomain.example.com` matches `*.example.com`
</div>
  
</div>

## Identify session needing refresh ## {#algo-identify-session-needing-refresh}
<div class="algorithm" data-algorithm="identify-session-needing-refresh">
  Given a [=request=] (|request|), this algorithm describes how to identify
  which session, if any, should block |request| from proceeding.

  1. Let |domain| be the [=host/registrable domain=] of the |request|'s
     [=request/url=]'s [=url/host=].
  1. Let |domain sessions| be the user agent's [=session store=][|domain|] as
     [=/session by id=]
  1. [=list/For each=] |session| of |domain sessions|
    1. If |session|'s [=expiration timestamp=] is before the present, remove
      |session| from |domain sessions| and [=iteration/continue=].
    1. Let |id| be |session|'s [=device bound session/session identifier=].
    1. If the [=tuple=] (|domain|, |id|) is in |request|'s
      [=deferred device bound session ids=], [=iteration/continue=].
    1. Run the steps in [[#algo-url-in-scope]] on |request|'s [=request/URL=]
       and |session|.
    1. If the result does not indicate the request is in scope,
      [=iteration/continue=].
    1. Run the steps in [[#algo-request-allows-refresh]] on |request| and
      |session|.
    1. If the result is not "allowed", [=iteration/continue=].
    1. If the result of running
      [[#algo-identify-missing-session-credential]] on |request| and
      |session|'s [=device bound session/session credentials=] is false,
      [=iteration/continue=].
    1. Add (|domain|, |id|) to |request|'s [=deferred device bound session ids=].
    1. Set |session|'s [=expiration timestamp=] set to a future timestamp. The
       exact choice of expiration timestamp is left to to the user agent. It is
       recommended to align with the maximum cookie lifetime.
    1. Return |session|.
  1. If no session has been identified, return null.
</div>

## Identify missing session credential ## {#algo-identify-missing-session-credential}
<div class="algorithm" data-algorithm="identify-missing-session-credential">
  Given a [=request=] (|request|) and a [=/list=] of [=/session credentials=]
  (|credentials|), returns a [=boolean=] indicating whether any |credential| in
  |credentials| is missing on |request|.
  
  1. [=list/For each=] |credential| in |credentials|
    1. If a cookie with |credential|'s [=session credential/attributes=] would
       not be attached to |request| (see <a
       href=https://httpwg.org/specs/rfc6265.html#cookie>section 5.4</a> of
       [[!COOKIES]]), [=iteration/continue=].
    1. If |request|'s [=request/header list=] contains a |cookie| that
       satisfies all of the following conditions, [=iteration/continue=]:
      1. |cookie|'s name matches |credential|'s [=session credential/name=]
      1. All of the following attributes of |cookie| match those in
         |credential|'s [=session credential/attributes=]: Domain, Path,
         Secure, HttpOnly, SameSite.
      1. |cookie|'s partition key matches that of |credential|.
    1. Return true.
  1. Return false.
</div>

## Cache challenge ## {#algo-process-challenge}
<div class="algorithm" data-algorithm="process-challenge">
  This algorithm describes how to
  <dfn export dfn-for="algorithms">process a challenge</dfn> received in an HTTP
  header.

  Given a [=response=] (|response|), this algorithm updates the [=device bound
  session/cached challenge=] for a [=device bound session=].

  1. Let |header name| be "<code>Secure-Session-Challenge</code>".
  1. Let |challenge list| be the result of executing <a>get a structured
    field value</a> given |header name| and "list" from |response|’s
    [=response/header list=].
  1. If |challenge list| is null, return.
  1. [=list/For each=] (|challenge|, |params|) of |challenge list|:
    1. If the type of |challenge| is not an <a>sf-string</a>,
      [=iteration/continue=].
    1. Let |session id| be null.
    1. If |params|["id"] exists and is an <a>sf-string</a>, set |session id| to
      |params|["id"].
    1. If |session id| is null, [=iteration/continue=].
    1. Let |session| be the result of running [[#algo-identify-session]] given
      |response|'s [=response/URL=] and |session id|.
    1. If |session| is null, [=iteration/continue=].
    1. [=list/For each=] |credential| in |session|'s [=device bound
       session/session credentials=]:
       1. If a cookie with |credential|'s [=session credential/attributes=] could
          not be set by |response| (see <a
          href=https://httpwg.org/specs/rfc6265.html#storage-model>section 5.3</a> of
          [[!COOKIES]]), [=iteration/continue=].
       1. Store |challenge| as |session|'s [=cached challenge=] to be used next
         time a [=DBSC proof=] is to be sent from this [=device bound session=].
       1. [=iteration/Break=].
</div>

## Send request ## {#algo-session-request}
<div class="algorithm" data-algorithm="session-request">
  This algorithm describes how to <dfn export dfn-for="algorithms">send
  a request</dfn> for a device bound session registration or refresh. It
  takes as input an |originating request|, |key pair|, |destination|,
  and optional |session id|, |challenge|, and |authorization|.

  1. The user agent MAY skip this request in order to prevent denial of service for
     the user or site. For example, this might happen if this session is
     requesting excessive TPM operations (harming the user) or the refresh
     endpoint has recently been unreachable (denial of service risk for the
     site). If the user agent chooses to do this, it should perform the steps of
     [[#algo-add-debug-header]] with |originating request|, an appropriate token (see
     options in [[#header-secure-session-skipped]]), and |session id|
     to indicate this to the site.
  1. Let |terminate the session| be an algorithm with the following steps:
    1. If |session id| is null, return.
    1. Remove the session with domain |destination|'s [=url/host=]'s
       [=host/registrable domain=] and identifier |session id| from the
       user agent's [=session store=], if such a session if found.
  1. If |originating request|'s [=request/URL=]'s [=/origin=] is not [=/same site=] with
     |destination|'s [=/origin=], return.
  1. Let |signed challenge| be null. If |challenge| is non-null, create
     a [=DBSC proof=] and sign it with |key pair| and store the result
     in |signed challenge|.
  1. Create a |request| for use in <a
     href="https://fetch.spec.whatwg.org/#http-fetch">HTTP fetch</a>.
  1. Set |request|'s [=request/method=] to "POST".
  1. Set |request|'s [=request/URL=] to |destination|.
  1. Set |request|'s [=request/redirect mode=] to "follow".
  1. If |signed challenge| is non-null, [=header list/append=] the header
     ("Secure-Session-Response", |signed challenge|) to |request|'s
     [=request/header list=].
  1. If |authorization| is non-null, [=header list/append=] the header
     ("Authorization", |authorization|) to |request|'s [=request/header list=].
  1. Set |request|'s [=request/initiator=] to |originating request|'s
     [=request/initiator=].
  1. Let |response| be the result of running <a
     href="https://fetch.spec.whatwg.org/#http-fetch">HTTP fetch</a> for |request|.
  1. If |response| is a [=network error=], or |response|'s
     [=response/status=] is 407 or 429, return.
  1. If |response|'s [=response/status=] is at least 300 and below 400, then
     return.
  1. If |response|'s [=response/status=] is 403:
    1. If |session id| is null, return.
    1. Let |session| be the result of running the steps of
       [[#algo-identify-session]] on |destination| and |session id|.
    1. If |session| is null, return.
    1. Otherwise, restart this algorithm with the original inputs, except
       replacing |challenge| with |session|'s [=cached challenge=].
  1. If |response|'s [=response/status=] is at least 400 and below 500,
     then |terminate the session| and return.
  1. If |response|'s [=response/status=] is at least 500, then
     return. User agents may choose to trigger a backoff mechanism on
     subsequent refresh requests on this session, to limit the harm of a
     temporary outage on the refresh endpoint.
  1. If |session id| is non-null, and |response|'s [=response/body=] is
     empty, return.
  1. Parse |response|'s [=response/body=] according to
     [[#format-session-instructions]]. If parsing fails, |terminate the
     session| and return.
  1. Let |session identifier| be the value of key "session_identifier".
  1. If the |response| JSON contains the key "continue", with value "false",
     |terminate the session| and return.
  1. Otherwise, perform the following validations. If any fail,
     |terminate the session| and return.
    1. |session identifier| must be non-empty.
    1. If |session id| is non-null, it must match |session identifier|.
    1. The value of the key "refresh_url" must be non-empty.
    1. Let |origin| be an [=/origin=] constructed from the value of the key
       "scope.origin", if present, or the origin of |destination| if
       not.
    1. |origin| must be a valid non-opaque origin.
    1. |origin| must be [=/same site=] with |destination|'s [=/origin=].
    1. Let |refresh URL| be the result of resolving |destination| with the value
       of the key "refresh_url".
    1. |refresh URL| must have scheme HTTPS or be localhost.
    1. |refresh URL|'s [=/origin=] must be [=/same site=] with |destination|'s [=/origin=].
  1. Let |destination domain| be the [=host/registrable domain=] of |destination|'s [=url/host=].
  1. If the value of the key "scope.include_site" in |response| is true,
     perform the following validations. If any fail, |terminate the
     session| and return.
    1. |origin|'s [=origin/domain=] must be equal to |destination domain|.
    1. If |destination domain| is equal to the [=url/host=] of
        |destination|, skip all remaining validations.
    1. Otherwise, let |well known URL| be a copy of |destination|, with the
       [=url/host=] replaced with |destination domain|, and the [=url/path=]
       replaced with "/.well-known/device-bound-sessions".
    1. Let |well known response| be the result of fetching |well known URL|.
    1. |well known response|'s [=response/status=] must be 200.
    1. |well known response|'s [=response/body=] must be a JSON-encoded
       dictionary.
    1. |well known response|'s [=response/body=] must include the key "registering_origins".
    1. The value of the key "registering_origins" must include the origin of
       |destination|.
  1. Let |session| be a new session with:
    1. [=device bound session/session identifier=] set to |session identifier|.
    1. [=refresh URL=] set to |refresh URL|.
    1. [=device bound session/session scope=] a new scope with [=session
       scope/origin=] |origin|, [=include site=] the value of the key
       "scope.include_site", and [=scope specifications=] the value of the key
       "scope.scope_specification".
    1. [=device bound session/session credentials=] the value of the key
       "credentials".
    1. [=session key=] set to |key pair|.
    1. [=allowed refresh initiators=] the value of the key
       "allowed_refresh_initiators".
    1. [=expiration timestamp=] set to a future timestamp. The exact choice of
       expiration timestamp is left to to the user agent. It is recommended to
       align with the maximum cookie lifetime.
  1. [=list/For each=] |credential| in |session|'s [=device bound
     session/session credentials=]:
    1. If a cookie with |credential|'s [=session credential/attributes=] could
       not be set by |response| (see <a
       href=https://httpwg.org/specs/rfc6265.html#cookie>section 5.3</a> of
       [[!COOKIES]]), [=iteration/continue=].
    1. Call |terminate the session| to remove the existing session.
    1. Set the user agent's [=session store=][|destination
       domain|][|session identifier|] to |session|.
    1. [=iteration/Break=].

## Create session ## {#algo-create-session}
<div class="algorithm" data-algorithm="process-registration">
To <dfn export id="create-session">create a new session</dfn> due to the
[=response=] (|response|) to a [=request=] (|request|), do the following steps:
  1. Let |header name| be "<code>Secure-Session-Registration</code>".
  1. Let |registration list| be the result of executing <a>get a structured
    field value</a> given |header name| and "list" from |response|’s
    [=response/header list=].
  1. If |registration list| is null, return.
  1. [=list/For each=] |registration entry|, |params| → |registration list|:
    1. If |registration entry| is not an <a>sf-inner-list</a>,
      [=iteration/continue=].
    1. If |params|["path"] does not exist, or is not of type <a>sf-string</a>,
      [=iteration/continue=].
    1. Let |path| be |params|["path"].
    1. Let |challenge| be null, and Let |authorization| be null.
    1. If |params|["challenge"] exists and is of type <a>sf-string</a>
      Set |challenge| to |params|["challenge"].
    1. If |params|["authorization"] exists and is a string Set |authorization|
      to |params|["authorization"].
    1. Let |endpoint| be the result of resolving |path| relative to the
       |response|'s URL.
    1. Let |key pair| be the result of running
       [[#algo-create-session-key]] on |registration entry|,
       |params|, and |endpoint|.
    1. If |key pair| is null, return.
    1. Call [[#algo-session-request]] with |request|, |key pair|, |endpoint|, null
       session identifier, |challenge| and |authorization|.
</div>

## Create session key ## {#algo-create-session-key}
<div class="algorithm" data-algorithm="create-session-key">

This algorithm describes how to <dfn export
id="create-session-key">create a session key</dfn>, including key
sharing between a Relying Party (RP) and Identity Provider (IdP). It
takes as input the |registration entry| and |params| of a
[:Secure-Session-Registration:] header, and the [=URL=] (|registration
URL|) of the registration endpoint. It returns a key pair for use in the
session or null if no key is possible.

  1. Let |algorithm list| be an empty [=list=].
  1. [=list/For each=] |algorithm| → |registration entry|
    1. If |algorithm| is not an <a>sf-token</a>, [=iteration/continue=].
    1. If |algorithm| represents a crypto algorithm supported in
       [:Secure-Session-Registration:], and is supported on this client,
       add |algorithm| to |algorithm list|.
  1. If |algorithm list| is empty, return null.
  1. If any of |params|["provider_key"], |params|["provider_id"], or
     |params|["provider_url"] exists:
    1. If any of the three keys is missing, return null.
    1. Let |provider URL| be a [=/URL=] constructed from
       |params|["provider_url"].
    1. Let |provider origin| be the [=url/origin=] of |provider URL|.
    1. If |provider origin| is opaque, return null.
    1. Let |provider domain| be the [=host/registrable domain=] of
       |provider URL|'s [=url/host=].
    1. Let |provider identifier| be |params|["provider_id"].
    1. Let |provider session| be the session in the user agent's
       [=session store=][|provider domain|][|provider identifier|].
    1. If |provider session| is null, return null.
    1. If |provider session|'s [=session key=] was created as the
       relying party from another session, return null.
    1. If |provider session|'s [=device bound session/session scope=]
       [=session scope/origin=] is not [=/same origin=] with |provider
       origin|, return null.
    1. If |provider session|'s [=session key=] does not match
       |params|["provider_key"], return null.
    1. Let |well known URL| be a copy of |provider URL|, with the
       [=url/path=] replaced with "/.well-known/device-bound-sessions".
    1. Let |well known response| be the result of fetching |well known
       URL|.
    1. If |well known response|'s [=response/status=] is not 200, return
       null.
    1. If |well known response|'s [=response/body=] is not a
       JSON-encoded dictionary, return null.
    1. If |well known response|'s [=response/body=] does not include the
       key "relying_origins", return null.
    1. If the value of the key "relying_origins" does not include the
       [=url/origin=] of |registration URL|, return null.
    1. User agents SHOULD place an upper limit on the number of
       [=registrable origin labels=] in "relying_origins" to prevent
       abuse.
    1. Return |provider session|'s [=session key=].
  1. Return a new key pair created for |algorithm list|.
</div>
 

## Add debug header ## {#algo-add-debug-header}
<div class="algorithm" data-algorithm="add-debug-header">
In order for sites to understand when the user agent chooses not to
apply a session, user agents should <dfn export
id="add-debug-header">add the debug header</dfn> to a [=request=]
(|request|) with an <a>sf-token</a> (|token|) and [=string=] (|session id|).
  1. Let |value| be an <a>sf-token</a> with value |token|.
  1. Set the <a>sf-parameter</a> "session_identifier" on |value| to |session id|.
  1. Let |skipped header value| be the result of running the steps of [=get a
     structured field value=] with [=header name=]
     "Secure-Session-Skipped", type "list", and |request|'s
     [=request/header list=].
  1. If |skipped header value| is null, set it to an empty <a>sf-list</a>.
  1. Append |value| to |skipped header value|.
  1. Run the steps of [=set a structured field value=] given
    ("Secure-Session-Skipped", |skipped header value|) on |request|'s
    [=request/header list=].
</div>

# DBSC Formats # {#format}
## \``Secure-Session-Registration`\` HTTP header field ## {#header-secure-session-registration}
The <dfn export http-header id="secure-session-registration-header">
<code>\`Secure-Session-Registration\`</code></dfn> header field can be used in a
[=response=] by the server to start a new [=/device bound session=] on the
client.

[:Secure-Session-Registration:] is a List Structured Header [[RFC9651]]. Its ABNF
is:

<pre class="abnf">Secure-Session-Registration = <a>sf-list</a></pre>

Each item in the list must be an inner list, and each item in the inner list
MUST be an <a>sf-token</a> representing a supported algorithm (ES256, RS256).
Only these two values are currently supported.

The following <a>sf-parameter</a>s are defined:
- An <a>sf-parameter</a> whose key is "path", and whose value is an
  <a>sf-string</a>, conveying the path to the registration endpoint. This may be
  relative to the current [=URL=], or a full [=URL=]. Entries without this
  parameter will be ignored in [[#algo-create-session]].
- An <a>sf-parameter</a> whose key is "challenge", and whose value is an
  <a>sf-string</a>, conveying the challenge to be used in the session
  registration.
- An <a>sf-parameter</a> whose key is "authorization", and whose value is an
  <a>sf-string</a>. This <a>sf-parameter</a> will be copied into the
  registration JWT.
- An <a>sf-parameter</a> whose key is "provider_key", and whose value is
  an <a>sf-string</a>, conveying that this session should share keys
  with a session with the given public key.
- An <a>sf-parameter</a> whose key is "provider_id", and whose value is
  an <a>sf-string</a>, conveying that this session should share keys
  with a session with the given session identifier.
- An <a>sf-parameter</a> whose key is "provider_url", and whose value
  is an <a>sf-string</a>, conveying that this session should share keys
  with a session on that site.

<div class="example" id="secure-session-registration-example">
  Some examples of [:Secure-Session-Registration:] from
  https://example.com/login.html:

  ```html
  HTTP/1.1 200 OK
  Secure-Session-Registration: (ES256);path="reg";challenge="cv";authorization="ac"
  ```
  ```html
  HTTP/1.1 200 OK
  Secure-Session-Registration: (ES256 RS256);path="reg";challenge="cv"
  ```
  ```html
  HTTP/1.1 200 OK
  Secure-Session-Registration: (ES256);path="reg1";challenge="cv1";authorization="a"
  Secure-Session-Registration: (RS256);path="reg2";challenge="cv2";authorization="b"
  ```
  ```html
  HTTP/1.1 200 OK
  Secure-Session-Registration: (ES256);path="reg1";challenge="cv1";authorization="a", (RS256);path="reg2";challenge="cv2";authorization="b"
  ```
  
  ```html
  HTTP/1.1 200 OK
  Secure-Session-Registration: (ES256);path="reg1";challenge="cv1";provider_key="abc";provider_id="idp_id";provider_url="https://id_origin.example.com"
  ```

</div>

## \``Secure-Session-Challenge`\` HTTP Header Field ## {#header-secure-session-challenge}
The <dfn export http-header id="secure-session-challenge-header">
<code>\`Secure-Session-Challenge\`</code></dfn> header field can be used in a
[=response=] by the server to send a challenge to the client that it expects to
be used in future Secure-Session-Response headers inside the [=DBSC proof=], or to
request a newly signed [=DBSC proof=] right away if the [=response/status=]
is 403.

[:Secure-Session-Challenge:] is a structured header. Its value must be a string.
Its ABNF is: <pre class="abnf">SecSessionChallenge = <a>sf-string</a></pre>
The semantics of the item are defined in
[[#challenge-structured-header-serialization]].

The processing steps are defined in [[#algo-process-challenge]].

### [:Secure-Session-Challenge:] structured header serialization ### {#challenge-structured-header-serialization}
The [:Secure-Session-Challenge:] is represented as a Structured Field.[[!RFC9651]]

In this representation, a challenge is represented by a string.

Challenges MAY have an <a>sf-parameter</a> named `"id"`, whose value MUST be a String
representing a [=device bound session/session identifier=]. Any other
<a>sf-parameter</a>s SHOULD be ignored.

Note: The server might need to use this header to request the [=DBSC proof=] to
be signed with a new challenge before a session id has been assigned. In this
case the session ID is optional.

<div class="example" id="secure-session-challenge-example">
  Some examples of [:Secure-Session-Challenge:] from
  https://example.com/login.html:

  ```html
  HTTP/1.1 403 Forbidden
  Secure-Session-Challenge: "new challenge"
  ```
  ```html
  HTTP/1.1 403 Forbidden
  Secure-Session-Challenge: "new challenge";id="my session"
  ```
  ```html
  HTTP/1.1 200 OK
  Secure-Session-Challenge: "new challenge";id="my session"
  ```
  ```html
  HTTP/1.1 200 OK
  Secure-Session-Challenge: "new challenge";id="my session 1"
  Secure-Session-Challenge: "another challenge";id="my session 2"
  ```
  ```html
  HTTP/1.1 200 OK
  Secure-Session-Challenge: "c1";id="session 1", "c2";id="session 2"
  ```
</div>

## \``Secure-Session-Response`\` HTTP Header Field ## {#header-secure-session-response}
The <dfn export http-header id="secure-session-response-header">
<code>\`Secure-Session-Response\`</code></dfn> header field can be used in the
[=request=] by the user agent to send a [=DBSC proof=] to the server to prove
that the client is still in possession of the private key of the session key.

<a http-header><code>\`Secure-Session-Response\`</code></a> is a structured
header. Its value must be a string. It's ABNF is:
<pre class="abnf">SecSessionChallenge = <a>sf-string</a></pre>
This string MUST only contain the [=DBSC proof=] JWT. Any <a>sf-parameter</a>s SHOULD be
ignored.

<div class="example" id="secure-session-response-example">
  ```html
  POST example.com/refresh
  Secure-Session-Response: "eyJhbGciOiJFUzI1NiIsInR5cCI6ImRic2Mrand0In0.eyJhdWQiOiJodHRwczovL2V4YW1wbGUuY29tL3JlZyIsImp0aSI6ImN2IiwiaWF0IjoiMTcyNTU3OTA1NSIsImp3ayI6eyJrdHkiOiJFQyIsImNydiI6IlAtMjU2IiwieCI6IjZfR0Iydm9RMHFyb01oNk9sREZDRlNfU0pyaVFpMVBUdnZCT2hHWjNiSEkiLCJ5IjoiSWVnT0pVTHlFN1N4SF9DZDFLQ0VSN2xXQnZHRkhRLWgweHlqelVqRUlXRSJ9LCJhdXRob3JpemF0aW9uIjoiYWMifQ.6Fb_vVBDmfNghQiBmIGe8o7tBfYPbPCywhQruP0vIhxgmcJmuNTaMHeVn_M8ZnOm1_bzIitbZqCWEn-1Qzmtyw"
  ```
</div>  

## \``Sec-Secure-Session-Id`\` HTTP Header Field ## {#header-sec-secure-session-id}
The <dfn export http-header id="sec-secure-session-id-header">
<code>\`Sec-Secure-Session-Id\`</code></dfn> header field can be used in the
[=request=] by the user agent to request the current session is refreshed, 
with the current session identifier as a string argument.

[:Sec-Secure-Session-Id:] is a structured header.
Its value must be a string. It's ABNF is:
<pre class="abnf">SecSessionIdentifier = <a>sf-string</a></pre>
This string MUST only contain the session identifier. Any parameters SHOULD be
ignored.

<div class="example" id="sec-secure-session-id-example">
  ```html
  POST example.com/refresh
  Sec-Secure-Session-Id: "session-id"
  ```
</div>

## \``Secure-Session-Skipped`\` HTTP header field ## {#header-secure-session-skipped}
The <dfn export http-header id="secure-session-skipped-header">
<code>\`Secure-Session-Skipped\`</code></dfn> header field can be used in a
[=request=] to indicate that the request is intentionally missing bound
credentials due to user agent policy.

[:Secure-Session-Skipped:] is a List Structured Header [[RFC9651]]. Its ABNF
is:

<pre class="abnf">Secure-Session-Skipped = <a>sf-list</a></pre>

Each item in the list must be MUST be an <a>sf-token</a> representing a
coarse-grained reason for skipping cookie refresh. The only supported values
are: "unreachable", "server_error", and "quota_exceeded".

One <a>sf-parameter</a> is defined:
- An <a>sf-parameter</a> whose key is "session_identifier", and whose value is an
  <a>sf-string</a>, conveying the identifier of the skipped session.
  
<div class="example" id="secure-session-skipped-example">
  ```html
  GET example.com/requires_bound_cookie
  Secure-Session-Skipped: unreachable;session_identifier=123, quota_exceeded;session_identifier=456
  ```
</div>


## JSON Session Instruction Format ## {#format-session-instructions}
The server sends <dfn>JSON session instructions</dfn> during session
registration and optionally during session refresh. If the response
contains session instructions, it MUST be in JSON format.

At the root of the JSON object, the following keys can exist:
  : session identifier
  :: a [=string=] representing a [=device bound session/session identifier=].
    If this [=JSON session instructions=] is sent during a refresh request this MUST be
    the [=device bound session/session identifier=] for the current session. If
    not these instructions SHOULD be ignored.
    If this [=JSON session instructions=] is sent during a registration it MUST either
    be a unique identifier for this [=host/registrable domain=], or it will
    overwrite the current [=device bound session=] with this identifier for the
    current [=host/registrable domain=].
    This key MUST be present.

  : refresh_url
  :: a [=string=] representing the [=URL=] used for future refresh requests.
    This can be a full [=URL=], or relative to the current [=request=].
    This key is OPTIONAL; if not present the registration URL will be used for
    future refresh requests.

  : continue
  :: a [=boolean=] indicating if the session should continue to apply.
    Registration and refresh endpoints can set this to false to terminate a session.
    This key is OPTIONAL, and if not present, the default value will be true.
    
  : scope
  :: a [=JSON session scope=] describing the request destinations covered by
    the session. This field MUST be present.

  : credentials
  :: a [=list=] of [=JSON session credentials=] describing the cookies protected by
    this session. This field MUST be present.

  : allowed_refresh_initiators
  :: a [=list=] of [=strings=] describing which hosts are allowed to initiate
    DBSC refreshes due to non-CORS requests. See
    [[#algo-request-allows-refresh]] for details.

<div class="example" id="secure-session-instruction-example">
  ```json
  {
    "session_identifier": "session_id",
    "refresh_url": "/RefreshEndpoint",

    "continue": false,
    "defer_requests": true, // optional and true by default

    "scope": {
      // Origin-scoped by default (i.e. https://example.com)
      // Specifies to include https://*.example.com except excluded subdomains.
      // This can only be true if the origin's host is the root eTLD+1.
      "origin": "https://example.com",
      "include_site": true,

      "scope_specification" : [
        { "type": "include", "domain": "trusted.example.com", "path": "/only_trusted_path" },
        { "type": "exclude", "domain": "untrusted.example.com", "path": "/" },
        { "type": "exclude", "domain": "*.example.com", "path": "/static" }
      ]
    },

    "credentials": [{
      "type": "cookie",
      // This specifies the exact cookie that this config applies to. Attributes
      // match the cookie attributes in RFC 6265bis and are parsed similarly to
      // a normal Set-Cookie line, using the same default values.
      // These SHOULD be equivalent to the Set-Cookie line accompanying this 
      // response.
      "name": "auth_cookie",
      "attributes": "Domain=example.com; Path=/; Secure; HttpOnly; SameSite=None"
      // Attributes Max-Age and Expires are ignored
    }],
    
    "allowed_refresh_initiators": [ "example.com", "*.example.com" ]
  }
  ```
</div>

## JSON Session Scope Instruction Format ## {#format-session-scope-instructions}
The server sends a <dfn>JSON session scope</dfn> in the [=JSON session
instructions=] during registration and optionally during session refresh.

At the root of the JSON object, the following keys can exist:
  : origin
  :: a [=string=] indicating the origin or site that the session applies to.
    This key is OPTIONAL; if not present, the origin of the URL serving the
    instructions will be used. This is the registration URL during registration
    and the refresh URL during refresh.
    
  : include_site
  :: a [=boolean=] indicating if the session is origin-scoped (false) or
    site-scoped (true). This key is MANDATORY. Note that this takes precedence
    over any [=JSON session scope rules=] in [=scope specification=] (see
    [[#algo-url-in-scope]]).
    
  : scope_specification
  :: a [=list=] of [=JSON session scope rules=] describing modifications to the
    default scope (the entire origin or site). This key is OPTIONAL; if not
    present, an empty list will be used.

## JSON Session Scope Rule Format ## {#format-session-scope-rule}
The server sends <dfn>JSON session scope rules</dfn> in the [=JSON session scope=]
during registration and optionally during session refresh.

At the root of each [=JSON session scope rule=], the following keys can exist:
  : type
  :: a [=string=] indicating whether the rule includes or excludes destinations.
    This key MUST be present, and the value MUST be "include" or "exclude".
    
  : domain
  :: a [=string=] indicating the domains that should match the rule. This key
    is OPTIONAL; if not present, it will be '*', matching all domains. This can
    include wildcards (see [[#algo-url-in-scope]]).
    
  : path
  :: a [=string=] indicating the path-prefixes that should match the rule. This
    key is OPTIONAL; if not present, it will be '/', matching all paths. See
    [[#algo-url-in-scope]] for the detailed semantics.

## JSON Session Credentials Format ## {#format-session-credentials}
The server sends <dfn>JSON session credentials</dfn> in the [=JSON session
instructions=] during registration and optionally during session refresh.

At the root of the JSON object, the following keys can exist:
  : type
  :: a [=string=] indicating the kind of credential protected by this session.
    This key MUST be present, and the value MUST be "cookie".
    
  : name
  :: a [=string=] indicating the name of the bound cookie.
    
  : attributes
  :: a [=string=] containing the expected attributes of the protected cookie.
    See [[#algo-identify-missing-session-credential]] for details on how this
    is used. 

## DBSC Proof JWT Syntax ## {#format-jwt}
A <dfn>DBSC proof</dfn> proof is a JWT that is signed (using JSON Web Signature
(JWS)), with a private key chosen by the client. The header of a [=DBSC proof=]
MUST contain at least the following <a>sf-parameter</a>s:
  : typ
  :: a [=string=] MUST be "dbsc+jwt"
  : alg
  :: a [=string=] defining the algorithm used to sign this JWT. It MUST be
    either "RS256" or "ES256" from [IANA.JOSE.ALGS].

The payload of [=DBSC proof=] MUST contain at least the following claims:
  : aud
  :: a [=string=], MUST be the [=URL=] this JWT was originally sent to.
    Example: "https://example.com/refresh.html"
  : jti
  :: a [=string=], a copy of the challenge value sent in the registration
    header.
  : iat
  :: a [=string=], this claim identifies the time at which the JWT was
    issued.  This claim can be used to determine the age of the JWT.  Its
    value MUST be a number containing a NumericDate value.
  : key
  :: a [=string=] defining a JWK as specified in [rfc7517].

In addition the following claims MUST be present if present in
[:Secure-Session-Registration:]:
  : authorization
  :: a [=string=], direct copy of the string from
    [:Secure-Session-Registration:], if set there. Note that this string is
    OPTIONAL to include in the header, but if it is present it is
    MANDATORY for clients to add the claim in the [=DBSC proof=].

If the DBSC proof is for a refresh request, the following claim MUST be
present:
  : sub
  :: the [=device bound session/session identifier=], a [=string=].

<div class="example" id="dbsc-proof-example">
  An example [=DBSC proof=] sent to https://example.com/reg:

  ```json
  // Header
  {
    "alg": "ES256",
    "typ": "dbsc+jwt"
  }
  // Payload
  {
    "aud": "https://example.com/reg",
    "jti": "cv",
    "iat": "1725579055",
    "key": {
      "kty": "EC",
      "crv": "P-256",
      "x": "6_GB2voQ0qroMh6OlDFCFS_SJriQi1PTvvBOhGZ3bHI",
      "y": "IegOJULyE7SxH_Cd1KCER7lWBvGFHQ-h0xyjzUjEIWE"
    },
    "authorization": "ac"
  }
  ```

  Based on this response header from the server:
  ```html
  HTTP/1.1 200 OK
  Secure-Session-Registration: (ES256);path="reg";challenge="cv";authorization="ac"
  ```
  received on a response from ```http://example.com/page.html```
</div>

# Changes to other specifications # {#changes-to-other-specifications}

## Changes to the Fetch specification ## {#changes-to-fetch}

This specification requires an update to the <a
href="https://fetch.spec.whatwg.org/#http-network-or-cache-fetch">HTTP-network-or-cache
fetch</a> algorithm. A [=request=] has a <dfn for="request">deferred device
bound session ids</dfn>, a [=list=] of [=tuples=] consisting of:
  - a domain (a [=host/registrable domain=]).
  - a session id (a [=string=]). 
This list is initially empty. After computing cookies in step 8.21, run
[[#algo-identify-session-needing-refresh]]. If the resulting
|session| is non-null:
  1. Run [[#algo-session-request]] with the returned |session|'s
    [=session key=], [=refresh URL=], [=device bound session/session
    identifier=], [=cached challenge=], and an empty authorization.
  2. Restart <a
    href="https://fetch.spec.whatwg.org/#http-network-or-cache-fetch">HTTP-network-or-cache
    fetch</a> with the original inputs.
    
## Changes to the Clear Site Data specification ## {#changes-to-clear-site-data}

This specification requires that the Clear Site Data specification
sections 4.2.5 "Clear DOM-accessible storage for origin" clear all
device bound sessions whose scope matches origin. It also requires an
update to 4.2.4 to clear device bound sessions for the site matching the
registered domain.

# IANA Considerations # {#iana-considerations}

The permanent message header field registry should be updated with the following
registrations: [[!RFC3864]]

## Secure-Session-Challenge ## {#iana-ses-session-challenge}
<dl>
  <dt>Header field name</dt>
  <dd>Secure-Session-Challenge</dd>

  <dt>Applicable protocol</dt>
  <dd>http</dd>

  <dt>Status</dt>
  <dd>draft</dd>

  <dt>Author/Change controller</dt>
  <dd>W3C</dd>

  <dt>Specification document</dt>
  <dd>This specification (See [[#header-secure-session-challenge]])</dd>
</dl>

## Sec-Secure-Session-Id ## {#iana-sec-secure-session-id}
<dl>
  <dt>Header field name</dt>
  <dd>Sec-Secure-Session-Id</dd>

  <dt>Applicable protocol</dt>
  <dd>http</dd>

  <dt>Status</dt>
  <dd>draft</dd>

  <dt>Author/Change controller</dt>
  <dd>W3C</dd>

  <dt>Specification document</dt>
  <dd>This specification (See [[#header-sec-secure-session-id]])</dd>
</dl>

## Secure-Session-Registration ## {#iana-secure-session-registration}
<dl>
  <dt>Header field name</dt>
  <dd>Secure-Session-Registration</dd>

  <dt>Applicable protocol</dt>
  <dd>http</dd>

  <dt>Status</dt>
  <dd>draft</dd>

  <dt>Author/Change controller</dt>
  <dd>W3C</dd>

  <dt>Specification document</dt>
  <dd>This specification (See [[#header-secure-session-registration]])</dd>
</dl>

## Secure-Session-Response ## {#iana-secure-session-response}
<dl>
  <dt>Header field name</dt>
  <dd>Secure-Session-Response</dd>

  <dt>Applicable protocol</dt>
  <dd>http</dd>

  <dt>Status</dt>
  <dd>draft</dd>

  <dt>Author/Change controller</dt>
  <dd>W3C</dd>

  <dt>Specification document</dt>
  <dd>This specification (See [[#header-secure-session-response]])</dd>
</dl>

## Secure-Session-Skipped ## {#iana-secure-session-skipped}
<dl>
  <dt>Header field name</dt>
  <dd>Secure-Session-Skipped</dd>

  <dt>Applicable protocol</dt>
  <dd>http</dd>

  <dt>Status</dt>
  <dd>draft</dd>

  <dt>Author/Change controller</dt>
  <dd>W3C</dd>

  <dt>Specification document</dt>
  <dd>This specification (See [[#header-secure-session-skipped]])</dd>
</dl>

## device-bound-sessions Well Known ## {#well-known}

The Well-Known URI registry should be updated to include
/.well-known/device-bound-sessions.

This endpoint must serve a JSON-encoded dictionary. Two keys are defined:
- "registering_origins" is a list of strings. It contains origins that
  are allowed to register sessions for an entire site.
- "relying_origins" is a list of strings. It contains origins that are
  allowed to be the Relying Party (RP) when sharing keys with this
  site's sessions.

<div class="example">
  If `https://example.com/.well-known/device-bound-sessions` serves
  ```json
  {
    "registering_origins": [
      "https://subdomain.example.com",
      "https://subdomain.example.com:8000",
    ],
    "relying_origins": [
      "https://example.co.uk",
      "https://example-partner.com",
    ],
  }
  ```
  Then registration requests can define a site-scoped session only if
  one of the following is true:
  - The registration endpoint has host `example.com`
  - The registration endpoint has origin `https://subdomain.example.com`
  - The registration endpoint has origin `https://subdomain.example.com:8000`
  
  In addition, `https://example.co.uk` and `https://example-partner.com`
  are allowed to share keys with sessions on `https://example.com`,
  enabling those sites to achieve both federated login and DBSC
  protection.
</div>

# Changelog # {#changelog}
This is an early draft of the spec.

# Acknowledgements # {#acknowledgements}
